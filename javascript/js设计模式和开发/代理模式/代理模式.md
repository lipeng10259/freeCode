# 代理模式
- [代理模式] 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。
            代理模式是一种非常有意义的模式，在生活中可以找到很多代理模式的场景。比如，明星都
            有经纪人作为代理。如果想请明星来办一场商业演出，只能联系他的经纪人。经纪人会把商业演
            出的细节和报酬都谈好之后，再把合同交给明星签。
            代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身
            对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之
            后，再把请求转交给本体对象 

- 代理模式的分类
    
    - [虚拟代理] 虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建  (应用,图片预加载 图片比较多的情况下可以等网页加载完之后在加载图片 ,)
       
      + 在Web 开发中，图片预加载是一种常用的技术，如果直接给某个img 标签节点设置src 属性，
      + 由于图片过大或者网络不佳，图片的位置往往有段时间会是一片空白。常见的做法是先用一张
      + loading 图片占位，然后用异步的方式加载图片，等图片加载好了再把它填充到img 节点里，这种
      + 场景就很适合使用虚拟代理。


      - 虚拟代理合并HTTP 请求

      - 虚拟代理在惰性加载中的应用
      - 
      - 虚拟代理实现图片预加载




  
    - [保护代理] 保护代理用于控制不同权限的对象对目标对象的访问

    - [代理的意义]  

      也许读者会有疑问，不过是实现一个小小的图片预加载功能，即使不需要引入任何模式也能
      办到，那么引入代理模式的好处究竟在哪里呢？下面我们先抛开代理，编写一个更常见的图片预
      加载函数。
      不用代理的预加载图片函数实现如下：
      var MyImage = (function(){
      var imgNode = document.createElement( 'img' );
      document.body.appendChild( imgNode );
      var img = new Image;
      img.onload = function(){
      imgNode.src = img.src;
      };
      return {
      setSrc: function( src ){
      imgNode.src = 'file:// /C:/Users/svenzeng/Desktop/loading.gif';
      img.src = src;
      }
      }
      })();
      MyImage.setSrc( 'http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );
      为了说明代理的意义，下面我们引入一个面向对象设计的原则——单一职责原则。
      单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变
      化的原因。如果一个对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可
      能会有多个。面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，
      等于把这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能
      会遭到意外的破坏。
      职责被定义为“引起变化的原因”。上段代码中的MyImage 对象除了负责给img 节点设置src
      外，还要负责预加载图片。我们在处理其中一个职责时，有可能因为其强耦合性影响另外一个职
      责的实现。
      另外，在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放—
      封闭原则。如果我们只是从网络上获取一些体积很小的图片，或者5 年后的网速快到根本不再需
      要预加载，我们可能希望把预加载图片的这段代码从MyImage 对象里删掉。这时候就不得不改动
      MyImage 对象了。
      实际上，我们需要的只是给img 节点设置src，预加载图片只是一个锦上添花的功能。如果
      能把这个操作放在另一个对象里面，自然是一个非常好的方法。于是代理的作用在这里就体现出
      来了，代理负责预加载图片，预加载的操作完成之后，把请求重新交给本体MyImage。

      纵观整个程序，我们并没有改变或者增加MyImage 的接口，但是通过代理对象，实际上给系
      统添加了新的行为。这是符合开放—封闭原则的。给img 节点设置src 和图片预加载这两个功能，
      被隔离在两个对象里，它们可以各自变化而不影响对方。何况就算有一天我们不再需要预加载，
      那么只需要改成请求本体而不是请求代理对象即可。

    - [代理和本体接口的一致性]


      上一节说到，如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请
      求本体。其中关键是代理对象和本体都对外提供了setSrc 方法，在客户看来，代理对象和本体
      是一致的， 代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别，这
      样做有两个好处。
       用户可以放心地请求代理，他只关心是否能得到想要的结果。
       在任何使用本体的地方都可以替换成使用代理。
      在Java 等语言中，代理和本体都需要显式地实现同一个接口，一方面接口保证了它们会拥
      有同样的方法，另一方面，面向接口编程迎合依赖倒置原则，通过接口进行向上转型，从而避开
      编译器的类型检查，代理和本体将来可以被替换使用。
      在JavaScript 这种动态类型语言中，我们有时通过鸭子类型来检测代理和本体是否都实现了
      setSrc 方法，另外大多数时候甚至干脆不做检测，全部依赖程序员的自觉性，这对于程序的健壮
      性是有影响的。不过对于一门快速开发的脚本语言，这些影响还是在可以接受的范围内，而且我
      们也习惯了没有接口的世界。
      另外值得一提的是，如果代理对象和本体对象都为一个函数（函数也是对象），函数必然都
      能被执行，则可以认为它们也具有一致的“接口”，代码如下：
      var myImage = (function(){
      var imgNode = document.createElement( 'img' );
      document.body.appendChild( imgNode );
      return function( src ){
      imgNode.src = src;
      }
      })();

      var proxyImage = (function(){
      var img = new Image;
      img.onload = function(){
      myImage( this.src );
      }
      return function( src ){
      myImage( 'file:// /C:/Users/svenzeng/Desktop/loading.gif' );
      img.src = src;
      }
    })();


   roxyImage( 'http:// imgcache.qq.com/music// N/k/000GGDys0yA0Nk.jpg' );


   - [缓存代理]
      
      缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参
      
      数跟之前一致，则可以直接返回前面存储的运算结果。 

    - 缓存代理的例子——计算乘积

        先创建一个用于求乘积的函数：
        var mult = function(){
        console.log( '开始计算乘积' );
        var a = 1;
        for ( var i = 0, l = arguments.length; i < l; i++ ){
        a = a * arguments[i];
        }
        return a;
        };
        mult( 2, 3 ); // 输出：6
        mult( 2, 3, 4 ); // 输出：24
        现在加入缓存代理函数：
        var proxyMult = (function(){
        var cache = {};
        return function(){
        var args = Array.prototype.join.call( arguments, ',' );
        if ( args in cache ){
        return cache[ args ];
        }
        return cache[ args ] = mult.apply( this, arguments );
        }
        })();
        proxyMult( 1, 2, 3, 4 ); // 输出：24
        proxyMult( 1, 2, 3, 4 ); // 输出：24


    - 缓存代理用于ajax异步请求数据

        我们在常常在项目中遇到分页的需求，同一页的数据理论上只需要去后台拉取一次，这些已
        经拉取到的数据在某个地方被缓存之后，下次再请求同一页的时候，便可以直接使用之前的数据。
        显然这里也可以引入缓存代理，实现方式跟计算乘积的例子差不多，唯一不同的是，请求数
        据是个异步的操作，我们无法直接把计算结果放到代理对象的缓存中，而是要通过回调的方式。
        具体代码不再赘述，读者可以自行实现。