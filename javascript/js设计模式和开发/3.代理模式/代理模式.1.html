<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

    <script>
        //代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。
        

        // 1 代理送花实例

        var Flower = function ( name ) {

            this.name = name ;

        } ;

        var xiaoming = {

            sendFlower : function ( target ) {

                var flower = new Flower('美丽的花') ; 

                target.receiveFlower ( flower ) ;

            }

        }

        var A = {

            receiveFlower : function ( flower ) {

                console.log(flower)
                alert('收到' + flower.name)
            }

        }

        xiaoming.sendFlower( A ) ;


        // 引入代理模式 B 小明通过 B 来给 A 送花
    
        var B = {

            receiveFlower : function (flower) {

                console.log(flower.name)

                A.receiveFlower ( flower )

            }


        }

        xiaoming.sendFlower( B ) ;

        // 很显然，执行结果跟第一段代码一致，至此我们就完成了一个最简单的代理模式的编写。
        // 也许读者会疑惑，小明自己去送花和代理B 帮小明送花，二者看起来并没有本质的区别，引
        // 入一个代理对象看起来只是把事情搞复杂了而已。
        // 的确，此处的代理模式毫无用处，它所做的只是把请求简单地转交给本体。但不管怎样，我
        // 们开始引入了代理，这是一个不错的起点。
        // 现在我们改变故事的背景设定，假设当A 在心情好的时候收到花，小明表白成功的几率有
        // 60%，而当A 在心情差的时候收到花，小明表白的成功率无限趋近于0。
        // 小明跟A 刚刚认识两天，还无法辨别A 什么时候心情好。如果不合时宜地把花送给A，花
        // 被直接扔掉的可能性很大，这束花可是小明吃了7 天泡面换来的。
        // 但是A 的朋友B 却很了解A，所以小明只管把花交给B，B 会监听A 的心情变化，然后选
        // 择A 心情好的时候把花转交给A，代码如下

    </script>

    




</body>
</html>