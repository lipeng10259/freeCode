<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // 策略模式的定义: 定义一系列的算法 ， 把他们一个个封装起来 ，并且使他们可以相互替换 。

        // 1 . 使用策略模式计算奖金

        //         很多公司的年终奖是根据员工的工资基数和年底绩效情况来发放的。例如，绩效为S 的人年
        // 终奖有4 倍工资，绩效为A 的人年终奖有3 倍工资，而绩效为B 的人年终奖是2 倍工资。假设财
        // 务部要求我们提供一段代码，来方便他们计算员工的年终奖。

        // 最初代码实现

        // 我们可以编写一个名为calculateBonus 的函数来计算每个人的奖金数额。很显然，
        // calculateBonus 函数要正确工作，就需要接收两个参数：员工的工资数额和他的绩效考核等级。
        // 代码如下：

        
        var calculateBonus = function (performanceLevel , salary ){

            if( performanceLevel === 'S' ) {

                return salary * 4 ;

            }

            if( performanceLevel === 'A' ){

                return salary * 3 ;
            
            } 

            if( performanceLevel === 'B' ){
               
                return salary * 2 ;
            
            }

        }
    
        calculateBonus( 'S' , 20000 )
        
        calculateBonus( 'A' , 6000 )



        // 可以发现，这段代码十分简单，但是存在着显而易见的缺点。
        //  calculateBonus 函数比较庞大，包含了很多if-else 语句，这些语句需要覆盖所有的逻辑
        // 分支。
        //  calculateBonus 函数缺乏弹性，如果增加了一种新的绩效等级C，或者想把绩效S 的奖金
        // 系数改为5，那我们必须深入calculateBonus 函数的内部实现，这是违反开放封闭原则的。
        //  算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢？我们的选择
        // 只有复制和粘贴。
        // 因此，我们需要重构这段代码。
    
    </script>
</body>
</html>