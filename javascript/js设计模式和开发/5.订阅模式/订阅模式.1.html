<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        //发布—订阅模式又叫观察者模式，
        
        //它定义对象间的一种一对多的依赖关系，当一个对象的状
        // 态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript 开发中，我们一般用事件模型
        // 来替代传统的发布—订阅模式。
    
        //         第一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。
        // 比如，我们可以订阅ajax 请求的error、succ 等事件。 或者如果想在动画的每一帧完成之后做一
        // 些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中
        // 使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴
        // 趣的事件发生点。
        // 第二点说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调
        // 用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼
        // 此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修
        // 改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就
        // 可以自由地改变它们。


        // 现实中的发布－订阅模式
        // 不论是在程序世界里还是现实生活中，发布—订阅模式的应用都非常之广泛。我们先看一个
        // 现实中的例子。
        // 小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼
        // MM告诉小明，不久后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。
        // 但到底是什么时候，目前还没有人能够知道。
        // 于是小明记下了售楼处的电话，以后每天都会打电话过去询问是不是已经到了购买时间。除
        // 了小明，还有小红、小强、小龙也会每天向售楼处咨询这个问题。一个星期过后，售楼MM 决
        // 定辞职，因为厌倦了每天回答1000 个相同内容的电话。
        // 当然现实中没有这么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在
        // 了售楼处。售楼MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一
        // 样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的时候，售楼MM会翻开花名册，
        // 遍历上面的电话号码，依次发送一条短信来通知他们。
    
    

        // 第一点说明发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。
        // 比如，我们可以订阅ajax 请求的error、succ 等事件。 或者如果想在动画的每一帧完成之后做一
        // 些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中
        // 使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴
        // 趣的事件发生点。
        // 第二点说明发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调
        // 用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼
        // 此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修
        // 改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就
        // 可以自由地改变它们。


        // DOM 事件
        // 实际上，只要我们曾经在DOM 节点上面绑定过事件函数，那我们就曾经使用过发布—订阅
        // 模式，来看看下面这两句简单的代码发生了什么事情：
        document.body.addEventListener( 'click', function(){
            alert(2);
        }, false );
        document.body.click(); // 模拟用户点击
        // 在这里需要监控用户点击document.body 的动作，但是我们没办法预知用户将在什么时候点
        // 击。所以我们订阅document.body 上的click 事件，当body 节点被点击时，body 节点便会向订阅
        // 者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息后等
        // 待售楼处发布消息。


        // 自定义事件
        // 除了DOM 事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布—
        // 订阅模式可以用于任何JavaScript 代码中。
        // 现在看看如何一步步实现发布—订阅模式。
        //  首先要指定好谁充当发布者（比如售楼处）；
        //  然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）；
        //  最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函
        // 数（遍历花名册，挨个发短信）。
        // 另外，我们还可以往回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，
        // 比如售楼处可以在发给订阅者的短信里加上房子的单价、面积、容积率等信息，订阅者接收到这
        // 些信息之后可以进行各自的处理：



        var salesOffices = {} ;// 定义售楼处

        salesOffices.clientList = [] ;  // 缓存列表 , 存放订阅者的回调函数

        salesOffices.listen = function ( fn ) {

            this.clientList.push ( fn ) ;

        } ;


        salesOffices.trigger = function () { // 发布者消息

            for ( var i = 0 , fn ; fn = this.clientList[ i++ ] ; ) {

                fn.apply( this , arguments ) ;// arguments 是发布消息时带上的参数

            };

        };

        // 测试

        salesOffices.listen ( function ( price , squareMeter ) {// 订阅者1

            console.log('价格= ' + price)

            console.log('squareMeter= ' + squareMeter)

        }) ;



        salesOffices.listen ( function ( price , squareMeter ) {// 订阅者2

            console.log('价格= ' + price)
            
            console.log('squareMeter= ' + squareMeter)

        }) ;


        salesOffices.trigger( 200000 , 188 )
        salesOffices.trigger( 200000 , 88 )





    </script>



</body>
</html>